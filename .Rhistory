knitr::opts_chunk$set(
fig.align = "center", message = F, warning = F, cache = T, cache.lazy = F,
class.source = "fold-hide"
)
data_norm_sub_trans <- data_norm_sub_trans %>%
# Factors are R-internal special vectors having "levels".
# All values must be a value of "levels". Internally, a factor is a numeric value pointing
# to one of the levels.
# ggplot is smart enough to handle factors properly (better than only vectors if needed)!
mutate(
sev_merge = factor(
sev_merge,
levels = c("healthy", "FLI", "HIV", "HBV", "mild/moderate", "severe/critical")
)
)
knitr::opts_chunk$set(
fig.align = "center", message = F, warning = F, cache = T, cache.lazy = F,
class.source = "fold-hide"
)
if (!require(pacman)) {
install.packages("pacman") # If not already installed
}
pacman::p_load("tidyverse", install = TRUE)
pacman::p_load("cowplot", install = TRUE)
pacman::p_load("uwot", install = TRUE)
pacman::p_load("data.table", install = TRUE)
pacman::p_load("pheatmap", install = TRUE) # Todo
pacman::p_load("needs", install = TRUE)
pacman::p_load("knitr", install = TRUE)
pacman::p_load("ggridges", install = TRUE)
pacman::p_load("grDevices", install = TRUE)
# Install BiocManager such that pacman can then find ComplexHeatmap by its own
pacman::p_load("BiocManager", install = TRUE)
pacman::p_load("ComplexHeatmap", install = TRUE)
# Github packages have to be dealt in a special way
# However you install them, you _need_ the "devtools" package
pacman::p_load("devtools", install = TRUE)
# Additionally, you might need "Rtools"
pacman::p_load_gh("JinmiaoChenLab/Rphenograph", install = TRUE)
pacman::p_load_gh("JinmiaoChenLab/cytofkit", install = TRUE) # To solve..
prioritize(dplyr) # Must be tested
theme_set(theme_classic())
# results='hide' does not print messages to the generated output file
# Standard read.csv, works for most things, but fread is faster.
# data_norm_sub <- read.csv("~/Documents/INsTRuCT_workshop/data_norm_sub5.csv")
data_norm_sub_fread <- data.table::fread("../data/data_norm_sub5.csv")
# fread is a special format, such that we have to convert it first into a usual data.frame
data_norm_sub <- data.frame(data_norm_sub_fread)
# Show the first 5 rows and all columns --> Rows are cells, columns are features per cell
print(data_norm_sub[1:5, ])
# Then take a look at only the column names
colnames(data_norm_sub)
panel <- colnames(data_norm_sub)[15:54]
# color_severity is a named vector which we will use later.
# #xxxxxx is a html-coded color code.
color_severity <- c(
"healthy" = "#0449FF",
"FLI" = "#807F7F",
"HIV" = "#40007F",
"HBV" = "magenta",
"mild/moderate" = "#FFB651",
"severe/critical" = "#F82000"
)
data_norm_sub %>%
# take only 20% of the data such that the plots are generated faster
sample_frac(0.2) %>%
# Pivot: All columns defined by "panel" will go into two columns.
# The values go into the new column "value"
# The names of the columns go into the new column "marker"
pivot_longer(names_to = "marker", values_to = "value", panel) %>%
# start plotting, x-axis is the value
ggplot(aes(x = value)) +
# We want density plots, so how the values on the x-axis are distributed
geom_density() +
# facet_wrap splits the plots according to the specified column, here "marker"
# scale="free" tells that the x-axis and y-axis are not the same for each plot
facet_wrap(~marker, scale = "free") +
# theme_classic() sets the look of the final plot
theme_classic()
# Transform all columns defined by "panel" with asinh()
data_norm_sub_trans <- data_norm_sub %>%
# Apply asinh() on all columns defined by panel
mutate_at(vars(panel), asinh)
data_norm_sub_trans %>%
# take only 20% of the data such that the plots are generated faster
sample_frac(0.2) %>%
# Pivot: All columns defined by "panel" will go into two columns.
# The values go into the new column "value"
# The names of the columns go into the new column "marker"
pivot_longer(names_to = "marker", values_to = "value", panel) %>%
# Start plotting, define "value" as x-axis
ggplot(aes(x = value)) +
# Density plots, how are the values on the x-axis distributed
geom_density() +
# Split the plots according to the "marker" column, different axis
facet_wrap(~marker, scale = "free") +
# How the plot looks
theme_classic()
data_norm_sub_trans %>%
# The plots would be overwhelmed with cells being exactly 0 (CyTOF-"ownness")
filter(CD45 > 0, CD3 > 0) %>%
# Use only 10% of the data
sample_frac(0.1) %>%
# Make a plot where the x-axis are the CD45 values, and the y-axis are the CD3 values
ggplot(aes(x = CD45, y = CD3)) +
# Each value will be a _point_ with a certain size
# and a certain transparency (alpha)
geom_point(size = 0.01, alpha = 0.1) +
# Additionally to the points, plot the density of the points in 2 dimensions
geom_density_2d() +
# Plot a rectangle with the given coordinates
# We found the coordinates by hand
# Alpha=0 because otherwise you would have a filled rectangle
geom_rect(mapping = aes(xmin = 1, xmax = 8, ymin = 4.3, ymax = 8), color = "black", alpha = 0)
data_norm_sub_trans %>%
# Retain all cells where the following rules apply
filter(
CD3 > 4.3,
CD45 > 1,
CD15 > 0,
CD19 > 0
) %>%
# Plot CD15 (y-axis) vs CD19 (x-axis)
ggplot(aes(x = CD19, y = CD15)) +
# Plot points with certain size and color alpha
geom_point(size = 0.01, alpha = 0.1) +
# Make 2d-density plots
geom_density_2d() +
# Plot a rectangle
# Alpha because geom_rect makes a filled rectangle otherwise
geom_rect(mapping = aes(
xmin = 0, xmax = 2.9, ymin = 0, ymax = 4
), color = "black", alpha = 0)
data_norm_sub_trans <- data_norm_sub_trans %>%
# ifelse(logical_value, if TRUE, if FALSE)
# ifelse returns the value inside if TRUE when the logical
# value is TRUE, otherwise the other value.
# Draw proper gates in the transformed values to get the (CD45+CD3+CD15-CD19-) cells
mutate(Tcell = ifelse(CD3 > 4.3 & CD45 > 1 & CD15 < 4 & CD19 < 2.9, TRUE, FALSE))
data_norm_sub_trans <- data_norm_sub_trans %>%
# Factors are R-internal special vectors having "levels".
# All values must be a value of "levels". Internally, a factor is a numeric value pointing
# to one of the levels.
# ggplot is smart enough to handle factors properly (better than only vectors if needed)!
mutate(
sev_merge = factor(
sev_merge,
levels = c("healthy", "FLI", "HIV", "HBV", "mild/moderate", "severe/critical")
)
)
knitr::opts_chunk$set(
fig.align = "center", message = F, warning = F, cache = T, cache.lazy = F,
class.source = "fold-hide"
)
if (!require(pacman)) {
install.packages("pacman") # If not already installed
}
pacman::p_load("tidyverse", install = TRUE)
pacman::p_load("cowplot", install = TRUE)
pacman::p_load("uwot", install = TRUE)
pacman::p_load("data.table", install = TRUE)
pacman::p_load("pheatmap", install = TRUE) # Todo
pacman::p_load("needs", install = TRUE)
pacman::p_load("knitr", install = TRUE)
pacman::p_load("ggridges", install = TRUE)
pacman::p_load("grDevices", install = TRUE)
# Install BiocManager such that pacman can then find ComplexHeatmap by its own
pacman::p_load("BiocManager", install = TRUE)
pacman::p_load("ComplexHeatmap", install = TRUE)
# Github packages have to be dealt in a special way
# However you install them, you _need_ the "devtools" package
pacman::p_load("devtools", install = TRUE)
# Additionally, you might need "Rtools"
pacman::p_load_gh("JinmiaoChenLab/Rphenograph", install = TRUE)
pacman::p_load_gh("JinmiaoChenLab/cytofkit", install = TRUE) # To solve..
prioritize(dplyr) # Must be tested
theme_set(theme_classic())
# results='hide' does not print messages to the generated output file
# Standard read.csv, works for most things, but fread is faster.
# data_norm_sub <- read.csv("~/Documents/INsTRuCT_workshop/data_norm_sub5.csv")
data_norm_sub_fread <- data.table::fread("../data/data_norm_sub5.csv")
# fread is a special format, such that we have to convert it first into a usual data.frame
data_norm_sub <- data.frame(data_norm_sub_fread)
# Show the first 5 rows and all columns --> Rows are cells, columns are features per cell
print(data_norm_sub[1:5, ])
# Then take a look at only the column names
colnames(data_norm_sub)
panel <- colnames(data_norm_sub)[15:54]
# color_severity is a named vector which we will use later.
# #xxxxxx is a html-coded color code.
color_severity <- c(
"healthy" = "#0449FF",
"FLI" = "#807F7F",
"HIV" = "#40007F",
"HBV" = "magenta",
"mild/moderate" = "#FFB651",
"severe/critical" = "#F82000"
)
data_norm_sub %>%
# take only 20% of the data such that the plots are generated faster
sample_frac(0.2) %>%
# Pivot: All columns defined by "panel" will go into two columns.
# The values go into the new column "value"
# The names of the columns go into the new column "marker"
pivot_longer(names_to = "marker", values_to = "value", panel) %>%
# start plotting, x-axis is the value
ggplot(aes(x = value)) +
# We want density plots, so how the values on the x-axis are distributed
geom_density() +
# facet_wrap splits the plots according to the specified column, here "marker"
# scale="free" tells that the x-axis and y-axis are not the same for each plot
facet_wrap(~marker, scale = "free") +
# theme_classic() sets the look of the final plot
theme_classic()
# Transform all columns defined by "panel" with asinh()
data_norm_sub_trans <- data_norm_sub %>%
# Apply asinh() on all columns defined by panel
mutate_at(vars(panel), asinh)
data_norm_sub_trans %>%
# take only 20% of the data such that the plots are generated faster
sample_frac(0.2) %>%
# Pivot: All columns defined by "panel" will go into two columns.
# The values go into the new column "value"
# The names of the columns go into the new column "marker"
pivot_longer(names_to = "marker", values_to = "value", panel) %>%
# Start plotting, define "value" as x-axis
ggplot(aes(x = value)) +
# Density plots, how are the values on the x-axis distributed
geom_density() +
# Split the plots according to the "marker" column, different axis
facet_wrap(~marker, scale = "free") +
# How the plot looks
theme_classic()
data_norm_sub_trans %>%
# The plots would be overwhelmed with cells being exactly 0 (CyTOF-"ownness")
filter(CD45 > 0, CD3 > 0) %>%
# Use only 10% of the data
sample_frac(0.1) %>%
# Make a plot where the x-axis are the CD45 values, and the y-axis are the CD3 values
ggplot(aes(x = CD45, y = CD3)) +
# Each value will be a _point_ with a certain size
# and a certain transparency (alpha)
geom_point(size = 0.01, alpha = 0.1) +
# Additionally to the points, plot the density of the points in 2 dimensions
geom_density_2d() +
# Plot a rectangle with the given coordinates
# We found the coordinates by hand
# Alpha=0 because otherwise you would have a filled rectangle
geom_rect(mapping = aes(xmin = 1, xmax = 8, ymin = 4.3, ymax = 8), color = "black", alpha = 0)
data_norm_sub_trans %>%
# Retain all cells where the following rules apply
filter(
CD3 > 4.3,
CD45 > 1,
CD15 > 0,
CD19 > 0
) %>%
# Plot CD15 (y-axis) vs CD19 (x-axis)
ggplot(aes(x = CD19, y = CD15)) +
# Plot points with certain size and color alpha
geom_point(size = 0.01, alpha = 0.1) +
# Make 2d-density plots
geom_density_2d() +
# Plot a rectangle
# Alpha because geom_rect makes a filled rectangle otherwise
geom_rect(mapping = aes(
xmin = 0, xmax = 2.9, ymin = 0, ymax = 4
), color = "black", alpha = 0)
data_norm_sub_trans <- data_norm_sub_trans %>%
# ifelse(logical_value, if TRUE, if FALSE)
# ifelse returns the value inside if TRUE when the logical
# value is TRUE, otherwise the other value.
# Draw proper gates in the transformed values to get the (CD45+CD3+CD15-CD19-) cells
mutate(Tcell = ifelse(CD3 > 4.3 & CD45 > 1 & CD15 < 4 & CD19 < 2.9, TRUE, FALSE))
data_norm_sub_trans <- data_norm_sub_trans %>%
# Factors are R-internal special vectors having "levels".
# All values must be a value of "levels". Internally, a factor is a numeric value pointing
# to one of the levels.
# ggplot is smart enough to handle factors properly (better than only vectors if needed)!
mutate(
sev_merge = factor(
sev_merge,
levels = c("healthy", "FLI", "HIV", "HBV", "mild/moderate", "severe/critical")
)
)
data_norm_sub_trans %>%
# count for each combination of
#   id:             Sample id
#   Tcell:          If it is a Tcell or not
#   sev_merge:      Which severity it is (sev_merge = mild+moderate and severe+critical merged)
#   Disease.phase:  acute or covalescent
# How many cells there are
# Count saves that in a new column "n"
count(id, Tcell, sev_merge, Disease.phase) %>%
# Result:
#     id Tcell       sev_merge Disease.phase     n
#     19 FALSE severe/critical         acute  1806
#     19  TRUE severe/critical         acute    22
#     15 FALSE severe/critical         acute  2407
# tidyverse functions can leverage "groups" of data, but you have to specify first
# what the group is defined on.
# Here we want to group the cells based on their (sample-) id
group_by(id) %>%
# We grouped the table by id (the sample)
#   Now we define perc as "n" divided by the sum of all "n"s times 100
# This is applied _inside each group_
# After each group has only two rows (Tcell = TRUE or FALSE)
# This is effectively the percentage of T-cells in each sample
mutate(perc = n / sum(n) * 100) %>%
# We do not need the grouping anymore, therefore remove it
ungroup() %>%
# Select only Tcells (As "Tcell" is a True/False column)
filter(Tcell) %>%
# plot the just calculated percentage on the y-axis
# And the severity on the x-axis
# "fill" fills plots, usually used for coloring.
ggplot(aes(y = perc, x = sev_merge, fill = sev_merge)) +
# Make a boxplot per fill-value. That happens automatically.
# Alpha sets the color-density
geom_boxplot(position = position_dodge(1), alpha = 0.7) +
# Overlay dotplot to the barplots
geom_dotplot(
binaxis = "y", stackdir = "center",
position = position_dodge(1), alpha = 0.7
) +
# facet_grid splits the plots according to multiple values,
# you could even use multiple splitting-values
# with "free_x" we allow the x-axis to vary between plots, but the y-axis is fixed.
facet_grid(~Disease.phase, space = "free_x", scale = "free_x") +
# Previously we defined the coloring for the severity stages, here we apply it.
scale_fill_manual(values = color_severity) +
# Set y-axis label
ylab("Percentage of T cells (%)") +
# Set x-axis label to empty ("")
xlab("") +
# Remove the x-axis text and ticks.
theme(
axis.text.x = element_blank(),
axis.ticks.x = element_blank()
)
print(session_info())
