---
title: "Tutorial INsTRuCT 2022"
output: 
  html_document:
    code_folding: 'hide'
    theme: yeti
    toc: true
    toc_depth: 2
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align='center', message=F, warning=F, cache=T,cache.lazy = F,
                      class.source="fold-hide")
```

## Load libraries

```{r lib}
library(tibble)
library(tidyr)
library(readr)
library(stringr)
library(ggplot2)
library(dplyr)
library(cowplot)
library(uwot)
library(Rphenograph)
library(cytofkit)
library(ComplexHeatmap)
theme_set(theme_cowplot())

# if(!require(devtools)){
#   install.packages("devtools") # If not already installed
# }
# devtools::install_github("JinmiaoChenLab/Rphenograph")
```

## Read the data

* Read the data table "data_norm_sub.csv" with the function read.csv. This data consist of 5% of the CyTOF data set from Georg et al. 2021. The data was already pre-processed (filter-out dead cells, doublets, debris, and batch-corrected)
* What are the columns? What are the rows?
* Create a vector with the name of each measured protein (panel)

```{r read, results="hide"}
#data_norm_sub <- read.csv("~/Documents/INsTRuCT_workshop/data_norm_sub5.csv")
data_norm_sub <- read.csv("/mnt/c/Users/woode/OneDrive - uni-duesseldorf.de/Uni/DOCTORATE/Teaching/instruct_workshop/tutorial/instructtutorial/data/data_norm_sub5.csv")

colnames(data_norm_sub)

data_norm_sub %>% dplyr::count(Run,id,Individuals,Group,Severity,Disease.phase,max..WHO.scale,sev_merge,Days.post.symptom.onset,Week, sev_week,followup)

panel <- colnames(data_norm_sub)[15:54]
```

* It is common practice to transform CyTOF marker intensities using, for example, arcsinh (inverse hyperbolic sine) with cofactor 5 to make the distributions more symmetric and to map them to a comparable range of expression, which is important for clustering.
* This transformation retains linearity in the low end of the count spectrum, but it resembles a log transformation in the high end. Cofactor determines the range of ion counts for which linearity is retained may be adjusted.
* Look at the example below.


```{r gateTcells1, fig.height=5, fig.width=10} 
p1 <- data_norm_sub %>% 
       dplyr::filter(CD3>0, CD19>0) %>% 
       sample_frac(0.1) %>% 
       dplyr::filter(CD3>0, CD19>0) %>% 
       ggplot(aes(x=CD3, y=CD19)) +
       geom_point(size = 0.01, alpha = 0.1) +
       geom_density_2d()+
       ggtitle('Untransformed')

p2 <- data_norm_sub %>% 
       dplyr::filter(CD3>0, CD19>0) %>% 
       sample_frac(0.1) %>% 
       mutate_at(vars(panel),asinh) %>% 
       dplyr::filter(CD3>0, CD19>0) %>% 
       ggplot(aes(x=CD3, y=CD19)) +
       geom_point(size = 0.01, alpha = 0.1) +
       geom_density_2d()+
       ggtitle('Arcsinh transformed')

plot_grid(p1,p2, nrow = 1)

```



## 1. Manual Gating

### 1.1 Gate B cells

* To avoid clustering all the cell types at once and thus increase the resolution of our cell population classification, we use manual gating on well-defined general immune cell subsets.

#### CD45+CD19+

* Using ggplot and geom_point, generate a scatter plot to decide the gates. Visualize just 10% of the data.
* Visualize the gates, using eg.: geom_rect.

```{r gateBcells1, fig.height=5, fig.width=5} 
data_norm_sub %>% 
 dplyr::filter(CD19>0, CD45>0) %>% 
 sample_frac(0.1) %>% 
 mutate_at(vars(panel),asinh) %>% 
 dplyr::filter(CD45>0, CD19>0) %>% 
 ggplot(aes(x=CD45, y=CD19)) +
 geom_point(size = 0.01, alpha = 0.1) +
 geom_density_2d()+
 geom_rect(mapping=aes(xmin=3, xmax=8, ymin=4, ymax=10), color="black", alpha=0) 

```

#### CD45+CD19+CD3-CD15-

* Further gate on CD3 and CD15

```{r gateBcells2, fig.height=5, fig.width=5}
data_norm_sub %>% 
 mutate_at(vars(panel),asinh) %>% 
 dplyr::filter(CD19>4 & CD19<10,
               CD45>4 & CD45<8,
               CD15>0, CD3>0) %>% 
 ggplot(aes(x=CD3, y=CD15)) +
 geom_point(size = 0.01, alpha = 0.1) +
 geom_density_2d()+
 geom_rect(mapping=aes(xmin=0, xmax=3.6, ymin=0, ymax=3), color="black", alpha=0) 
```

```{r gateBcells3, fig.height=5, fig.width=5}
data_norm_sub %>% 
 mutate_at(vars(panel),asinh) %>% 
 dplyr::filter(CD19>4 & CD19<10,
               CD45>4 & CD45<8,
               CD15<3, CD3<3.6,
               CD56>0, CD14>0) %>% 
 ggplot(aes(x=CD56, y=CD14)) +
 geom_point(size = 0.01, alpha = 0.1) +
 geom_density_2d()+
 geom_rect(mapping=aes(xmin=0, xmax=2.7, ymin=0, ymax=3.5), color="black", alpha=0) 
```


#### Percentage of B cells

* Add a column to the data table where each cell gets the classification B cell = {TRUE, FALSE} according to your gating strategy. (flagging)
* Calculate the percentage of B cells in each sample.
* Visualize the percentage of B cells grouped by severity group (use the classification "sev_merge"), using eg.: geom_boxplot, and facet by disease phase.
* Why do you think the numbers vary so much?

```{r columnBcells}
data_norm_sub <- data_norm_sub %>% mutate(Bcell = ifelse(CD19>sinh(4) & CD19<sinh(10) & CD45>sinh(4) & CD45<sinh(8) & CD3<sinh(3.6) & CD15<sinh(3) & CD14<sinh(3.5) & CD56<sinh(2.7), TRUE, FALSE))

```

```{r color_sev}
color_severity <- c(
  "healthy" = "#0449FF", 
  "FLI" =  "#807F7F", 
  "HIV" = "#40007F", 
  "HBV" =  "magenta",
  "mild/moderate" = "#FFB651", 
  "severe/critical" = "#F82000")
```


```{r percBcells}

data_norm_sub <- data_norm_sub %>% mutate(sev_merge = factor(sev_merge,levels = c("healthy","FLI","HIV","HBV","mild/moderate","severe/critical")))

data_norm_sub %>% 
 dplyr::count(id,Bcell,sev_merge,Disease.phase) %>% 
 group_by(id) %>% 
 mutate(perc = n/sum(n)*100) %>% 
 ungroup() %>% 
 dplyr::filter(Bcell) %>% 
 ggplot(aes(y = perc, x = sev_merge, fill = sev_merge)) + 
 geom_boxplot(position=position_dodge(1), alpha = 0.7)+
 geom_dotplot(binaxis='y', stackdir='center',
              position=position_dodge(1), alpha = 0.7)+
 facet_grid(~ Disease.phase, space = "free_x", scale = "free_x") + 
 scale_fill_manual(values = color_severity)+
 ylab("Percentage of B cells (%)") + 
 xlab("")+
 theme(axis.text.x=element_blank(),
       axis.ticks.x=element_blank())
```


## 3. UMAP

* Compute the UMAPs for B cells across all samples (acute and convalescent), and using all markers, except the channels we used for gating, and also excluding CD45RO and CRTH2.
* Define a vector "sel_markers" with the selected markers to be used for the calculation of the UMAP.

```{r sel_markers}
sel_markers <- panel[!panel %in% c("CD45","CD3", "CD19","CD15","CD8","TCRgd","CD45RO","CRTH2","CD14")]

```

```{r subsetB}
data_Bcell <- dplyr::filter(data_norm_sub, Bcell==T)

```



* Before calculation of the UMAP, is important we transform our data ("asinh") and apply z-score normalization (function "scale"). Why?
* What information can we gain from UMAP?

```{r computeUMAP}

UMAP_B <- data_Bcell %>%
  mutate_at(vars(sel_markers), asinh) %>% 
  mutate_at(vars(sel_markers), scale) %>% 
  dplyr::select(sel_markers) %>%
  uwot::umap(n_neighbors = 30,spread = 1, min_dist = 0.5,metric = "euclidean", verbose = TRUE, fast_sgd = TRUE)

#### Add UMAP information to data frame

data_Bcell$UMAP1 <- NA
data_Bcell$UMAP2 <- NA

data_Bcell$UMAP1 <- UMAP_B[,1]

data_Bcell$UMAP2 <- UMAP_B[,2]

```

### Severity

* Plot each UMAP, coloured by severity.
* Do you observe specific areas where CV19 samples accumulate? What does this mean?

```{r UMAP_severity, fig.height=7, fig.width=7}


data_Bcell %>% 
  ggplot(aes(x = UMAP1, y=UMAP2, color = sev_merge)) +
  geom_point(alpha = 0.5,size = 2)+
  guides(colour = guide_legend(ncol = 1,override.aes = list(size=3, alpha = 1))) +
  scale_color_manual(values = color_severity, name = "")+
  theme_classic() + 
  ggtitle("CD4+") +
  theme(legend.position = "none",plot.title = element_text(hjust = 0.5)) 


```

### Disease phase

* Plot each UMAP using only COVID-19, coloured by disease phase (acute or convalescent)
* Do you observe specific areas where convalescent samples acumulate? What does this mean?

```{r UMAP_diseasephase, fig.height=7, fig.width=7}


data_Bcell %>% 
  ggplot(aes(x = UMAP1, y=UMAP2, color = Disease.phase)) +
  geom_point(alpha = 0.5,size = 2)+
  guides(colour = guide_legend(ncol = 1,override.aes = list(size=3, alpha = 1))) +
  scale_color_manual(values = c("acute" = "red","convalescent"="black"), name = "")+
  theme_classic() + 
  ggtitle("CD4+") +
  theme(legend.position = "none",plot.title = element_text(hjust = 0.5)) 


```

### Marker intensity

* Plot the UMAPs coloured by the expression of your favorite marker. Remember to do the corresponding transformations on the intensity values.
* Recommendation: subsample CD4+ and CD8+ T cells for visualization, using sample_n, or sample_frac.

```{r UMAP_markers, fig.height=7, fig.width=21}


p1 <- data_Bcell %>% 
      mutate_at(vars(sel_markers), asinh) %>% 
      mutate_at(vars(sel_markers), scale) %>%
      ggplot(aes(x = UMAP1, y=UMAP2, color = CD34)) +
      geom_point(alpha = 0.5,size = 2)+
      theme_classic() + 
      ggtitle("CD34 signal") +
      theme(legend.position = "none",plot.title = element_text(hjust = 0.5)) +
      scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = 0)

p2 <- data_Bcell %>% 
      mutate_at(vars(sel_markers), asinh) %>% 
      mutate_at(vars(sel_markers), scale) %>%
      ggplot(aes(x = UMAP1, y=UMAP2, color = IgM)) +
      geom_point(alpha = 0.5,size = 2)+
      theme_classic() + 
      ggtitle("IgM signal") +
      theme(legend.position = "none",plot.title = element_text(hjust = 0.5)) +
      scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = 0)

p3 <- data_Bcell %>% 
      mutate_at(vars(sel_markers), asinh) %>% 
      mutate_at(vars(sel_markers), scale) %>%
      ggplot(aes(x = UMAP1, y=UMAP2, color = CD38)) +
      geom_point(alpha = 0.5,size = 2)+
      theme_classic() + 
      ggtitle("CD38 signal") +
      theme(legend.position = "none",plot.title = element_text(hjust = 0.5)) +
      scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = 0)



plot_grid(p1,p2,p3, nrow = 1)

```

## 4. Unsupervised clustering (of acute samples)

* Perform unsupervised clustering analysis on samples from control, FLI, HIV, HBV, and acute COVID-19 using all the markers, except the channels we used for gating and the ones that do not have a function in B cells (same markers used for UMAP)
* As done for the UMAP calculation, before clustering is important we transform and z-score normalize our data.

### 3.1 RPhenograph

```{r runRphenograph, results="hide"}
start_time <- Sys.time()

clust_cd8 <- data_Bcell %>% 
 mutate_at(vars(sel_markers), asinh) %>% 
 mutate_at(vars(sel_markers), scale) %>% 
 dplyr::filter(Disease.phase == "acute") %>%
 dplyr::select(sel_markers) %>% 
 Rphenograph(k = 30)

end_time <- Sys.time()

```
```{r}
time_elapsed <- round(as.numeric(gsub('Time difference of ', '', difftime(end_time, start_time, units = "mins"))), 2)

print(paste(time_elapsed, 'minutes passed'))
```

* Add a column "Rpheno" in the main data table with the cluster label for each cell

```{r add_clust_info}
clust_ids <- data_Bcell %>% 
   dplyr::filter(Disease.phase == "acute") %>%
   pull(cellid)

clust_cd8 <- tibble(cellid = clust_ids, Rpheno = as.character(membership(clust_cd8[[2]])))

data_Bcell <- data_Bcell %>% left_join(clust_cd8)
data_Bcell <- data_Bcell %>% mutate(Rpheno = factor(Rpheno, levels = str_sort(unique(Rpheno), numeric = TRUE)))

```

#### Cluster size

* Visualize the number of cells in each cluster 
* How are the cells distributed across clusters? What do you expect to happen if we increase the number of cells in the dataset?

```{r clustSize, fig.height=5, fig.width=10}
 data_Bcell %>% dplyr::filter(data_Bcell$Disease.phase == "acute" ) %>%
 dplyr::count(Rpheno) %>% 
 ggplot(aes(x = Rpheno, y = n, label = n))+
 geom_col(position = "dodge") + geom_label() 
```

#### UMAP clusters

* Would you say that classification fits the clusters observed in the UMAP?
* Are there immediate problems you see with the classification?
* Why don't clusters match up completely?

```{r UMAP_clusters, fig.height=5, fig.width=7}
data_Bcell %>% 
  dplyr::filter(data_Bcell$Disease.phase == "acute") %>% 
  ggplot(aes(x = UMAP1, y=UMAP2, color = Rpheno)) +
  geom_point(alpha = 0.5,size = 1)+
  guides(colour = guide_legend(ncol = 1,override.aes = list(size=3, alpha = 1))) +
  theme_classic() + 
  ggtitle("CD8+") +
  theme(plot.title = element_text(hjust = 0.5)) 


```


#### Heatmap clusters

* To understand the clusters we found, visualize in a heatmap the average expression of each marker in each cluster. 
* Remember to do the corresponding transformation of the intensity values. 


```{r heatmapClusters, fig.height=5, fig.width=5}
order_vec <- rev(c('IgD','IgM','CD10','CD21','HLADR','CXCR5','CD27','CD38','CD25','CXCR3','CD62L','CCR6','CD69','CD34','Ki67','CD95','CD11c','CD137','CD226','ICOS','PD1','Lag3','TIGIT','CD96','CD123','KLRB1','KLRG1','KLRF1','CD16','CD28','CD56'))
sel_markers <- factor(sel_markers,levels = order_vec)
data_Bcell %>% 
 mutate_at(vars(sel_markers), asinh) %>% 
 mutate_at(vars(sel_markers), scale) %>% 
 dplyr::filter(Disease.phase == "acute") %>%
 dplyr::select(sel_markers,Rpheno) %>%
 group_by(Rpheno) %>%
 summarise_at(vars(sel_markers), funs(mean(., na.rm=TRUE))) %>% 
 pivot_longer(names_to = "markers", values_to = "avg_zscore", - Rpheno) %>% 
 mutate(markers = factor(markers,levels = order_vec)) %>% 
 ggplot(aes(x = Rpheno, y = markers, fill = avg_zscore)) + 
 geom_tile() + 
 scale_fill_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4,4)) 

```

* With the library "ComplexHeatmap" we can additionally group the clusters (dendogram) by their similarities.
* Try to do basic annotation of the clusters.

```{r heatmapOriginalClusters, fig.height=10, fig.width=10}

data_heatmap <- data_Bcell %>% 
 mutate_at(vars(sel_markers), asinh) %>% 
 mutate_at(vars(sel_markers), scale) %>% 
 dplyr::filter(Disease.phase == "acute") %>%
 dplyr::select(sel_markers,Rpheno) %>%
 group_by(Rpheno) %>%
 summarise_at(vars(rev(sel_markers)), funs(mean(., na.rm=TRUE))) %>%
 column_to_rownames("Rpheno")
data_heatmap <- data_heatmap[,rev(order_vec)]

data_heatmap %>% t() %>% 
 Heatmap(name = "z-score avg", 
         cluster_rows = FALSE, 
         cluster_columns = TRUE,
         rect_gp = gpar(col = "white", lwd = 2),
         column_dend_height = unit(4, "cm"),
         column_names_rot = 45,
         row_title_rot = 0
 )

```


### 3.1 FlowSOM

*IMPORTANT! We have to select the number of metaclusters manually!
```{r runflowsom, results="hide"}
set.seed(1234) #set random seed for reproducibility

start_time <- Sys.time()

flowsom_meta <- 10 #input the number of clusters you want to recieve at the end

clust_cd8 <- data_Bcell %>% 
 mutate_at(vars(sel_markers), asinh) %>% 
 mutate_at(vars(sel_markers), scale) %>% 
 dplyr::filter(Disease.phase == "acute") %>%
 dplyr::select(sel_markers) %>% 
 cytof_cluster(xdata=. , method = 'FlowSOM', FlowSOM_k = flowsom_meta)

end_time <- Sys.time()



```
```{r}
time_elapsed <- round(as.numeric(gsub('Time difference of ', '', difftime(end_time, start_time, units = "mins"))), 2)

print(paste('\n', time_elapsed, 'minutes passed'))
```

* Add a column "flowsom" in the main data table with the cluster label for each cell

```{r add_clust_info}
#clust_ids <- data_Bcell %>% 
#   dplyr::filter(Bcellcompartment == "CD8+",Disease.phase == "acute") %>%
#   pull(cellid)

clust_cd8 <- tibble(cellid = clust_ids, flowsom = as.character(clust_cd8))

data_Bcell <- data_Bcell %>% left_join(clust_cd8)
data_Bcell <- data_Bcell %>% mutate(flowsom = factor(flowsom, levels = str_sort(unique(flowsom), numeric = TRUE)))

```

#### Cluster size

* Visualize the number of cells in each cluster
* Are the cells distributed differently?
* What do you expect to happen as we increase the number of cells in the input?

```{r clustSize, fig.height=5, fig.width=10}
 data_Bcell %>% dplyr::filter(data_Bcell$Disease.phase == "acute" ) %>%
 dplyr::count(flowsom) %>% 
 ggplot(aes(x = flowsom, y = n, label = n))+
 geom_col(position = "dodge") + geom_label() 
```

#### UMAP clusters

* Would you say that classification fits the clusters observed in the UMAP?
* Are there immediate problems you see with the classification?
* How is the clustering different from PhenoGraph?

```{r UMAP_clusters, fig.height=5, fig.width=7}
data_Bcell %>% 
  dplyr::filter(data_Bcell$Disease.phase == "acute") %>% 
  ggplot(aes(x = UMAP1, y=UMAP2, color = flowsom)) +
  geom_point(alpha = 0.5,size = 1)+
  guides(colour = guide_legend(ncol = 1,override.aes = list(size=3, alpha = 1))) +
  theme_classic() + 
  ggtitle("B Cells") +
  theme(plot.title = element_text(hjust = 0.5)) 


```


#### Heatmap clusters

* To understand the clusters we found, visualize in a heatmap the average expression of each marker in each cluster. 
* Remember to do the corresponding transformation of the intensity values. 


```{r heatmapClusters, fig.height=5, fig.width=5}

data_Bcell %>% 
 mutate_at(vars(sel_markers), asinh) %>% 
 mutate_at(vars(sel_markers), scale) %>% 
 dplyr::filter(Disease.phase == "acute") %>%
 dplyr::select(sel_markers,flowsom) %>%
 group_by(flowsom) %>%
 summarise_at(vars(sel_markers), funs(mean(., na.rm=TRUE))) %>% 
 pivot_longer(names_to = "markers", values_to = "avg_zscore", - flowsom) %>% 
 mutate(markers = factor(markers,levels = order_vec)) %>% 
 ggplot(aes(x = flowsom, y = markers, fill = avg_zscore)) + 
 geom_tile() + 
 scale_fill_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4,4)) 

```

* With the library "ComplexHeatmap" we can additionally group the clusters (dendogram) by their similarities.
* Try to do basic annotation of the clusters.
* Are they different from PhenoGraph ones?

```{r heatmapOriginalClusters, fig.height=10, fig.width=10}

data_heatmap <- data_Bcell %>% 
 mutate_at(vars(sel_markers), asinh) %>% 
 mutate_at(vars(sel_markers), scale) %>% 
 dplyr::filter( Disease.phase == "acute") %>%
 dplyr::select(sel_markers,flowsom) %>%
 group_by(flowsom) %>%
 summarise_at(vars(sel_markers), funs(mean(., na.rm=TRUE))) %>%
 column_to_rownames("flowsom")
data_heatmap <- data_heatmap[,rev(order_vec)]

data_heatmap %>% t() %>% 
 Heatmap(name = "z-score avg", 
         cluster_rows = FALSE, 
         cluster_columns = TRUE,
         rect_gp = gpar(col = "white", lwd = 2),
         column_dend_height = unit(4, "cm"),
         column_names_rot = 45,
         row_title_rot = 0
 )

```



# 5. Cluster abundance

* What is the abundance of each cluster in each sample? 
* Is there any COVID-specific cluster?
* ACHTUNG! In this data set, donors where sampled multiple times during the disease course. For statistical purposes, we need to select one sample per donor. Hence, we establish an arbitrary rule of choosing the first sample per donor when multiple samples are available.

## 5.1 Select first sample per donor.

For the non-weekly analysis, we considered the first sample per patient when multiple samples were available.

```{r defineIDs}
selected_ids <- data_Bcell %>% 
  dplyr::filter(Disease.phase == "acute") %>% 
 dplyr::count(Individuals,id,Group,sev_merge,Days.post.symptom.onset) %>% 
 dplyr::select(-n) %>% 
 group_by(Individuals) %>%
 mutate(n_samples = 1:n()) %>% 
 mutate(select_id = ifelse(n_samples == 1, TRUE,
                                  ifelse(min(as.numeric(Days.post.symptom.onset)) == as.numeric(Days.post.symptom.onset), 
                                         TRUE,
                                         FALSE))) %>%
 dplyr::filter(select_id) %>%
 pull(id)
```


## 5.2 Cluster abundance (non-weekly analysis) {.tabset}

* Calculate the abundance of each cluster in each selected donor, and visualize it with boxplots grouped by severity. 

```{r boxplot_clust_abundance, fig.height=10, fig.width=10}

 data_Bcell %>% 
 dplyr::filter(id %in% selected_ids) %>% 
 dplyr::count(id,sev_merge,Rpheno) %>% 
 group_by(id) %>% 
 mutate(perc = n/sum(n)*100) %>% 
 ungroup() %>% 
  # When using the function count(), if a cluster is absent in a donor, it will not be counted as zero. 
  # So we complete the count table by filling the missing clusters with a 0.
 tidyr::complete(id,Rpheno,fill = list(n=0,perc = 0)) %>% 
 ungroup() %>% 
 group_by(Rpheno) %>% 
 fill(.direction = "downup") %>% 
 ungroup() %>% 
 group_by(id) %>% 
 fill(sev_merge, .direction = "downup") %>% 
 ungroup() %>% 
 mutate(perc = ifelse(is.na(perc),0,perc)) %>% 
 ggplot(aes(x = sev_merge, y = perc, fill = sev_merge)) + 
 geom_boxplot() + 
 geom_jitter()+
 facet_wrap(~Rpheno, scale = "free") + 
 scale_fill_manual(values = color_severity) + 
 theme(axis.text.x = element_blank()) +
  ggtitle('Rphenograph cluster abundances')
```


```{r boxplot_clust_flow_abundance, fig.height=10, fig.width=10}

 data_Bcell %>% 
 dplyr::filter(id %in% selected_ids) %>% 
 dplyr::count(id,sev_merge,flowsom) %>% 
 group_by(id) %>% 
 mutate(perc = n/sum(n)*100) %>% 
 ungroup() %>% 
  # When using the function count(), if a cluster is absent in a donor, it will not be counted as zero. 
  # So we complete the count table by filling the missing clusters with a 0.
 tidyr::complete(id,flowsom,fill = list(n=0,perc = 0)) %>% 
 ungroup() %>% 
 group_by(flowsom) %>% 
 fill(.direction = "downup") %>% 
 ungroup() %>% 
 group_by(id) %>% 
 fill(sev_merge, .direction = "downup") %>% 
 ungroup() %>% 
 mutate(perc = ifelse(is.na(perc),0,perc)) %>% 
 ggplot(aes(x = sev_merge, y = perc, fill = sev_merge)) + 
 geom_boxplot() + 
 geom_jitter()+
 facet_wrap(~flowsom, scale = "free") + 
 scale_fill_manual(values = color_severity) + 
 theme(axis.text.x = element_blank()) +
  ggtitle('flowsom cluster abundances')
```

* How different are the cluster abundances observed between the algorithms? What are the differences?
* Which algorithm performs better in your opinion?